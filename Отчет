ГБОУ «Президентский ФМЛ №239»
Создание 2D игры с помощью движка Unity
Годовой проект по информатике
Терехова Алина, 10-3 класс




















Постановка задачи
Перед учениками 10х классов в начале года была поставлена задача: создать программу на каком-либо языке программирования, предназначенную для конкретной цели. Мною была выбрана тема создания 2D игры (платформера) с помощью движка Unity. 
Таким образом, глобальной целью являлось создание 2D игры.
Для достижения глобальной цели необходимо было выполнить конкретные задачи:
•	Научиться работать с движком Unity и использовать соответствующие библиотеки
•	Научиться использовать язык C# для программирования игр
Для успешного выполнения проекта (поставленной задачи) нужно было сделать:
1.	Используя какую-либо среду разработки (Visual Studio в моем случае) написать код на языке C#, описывающий поведение игровых объектов и позволяющий успешно реализовывать игру. 
2.	Создать на движке Unity игру 
a.	Подобрать текстуры
b.	Подобрать аудио сопровождение
c.	Подобрать спрайты для героя и монстров
d.	Создать главное меню, уровни, меню завершение игры
e.	Добавить на уровни монстров и персонажа, используя технологии Unity 
После создания программы (игры) необходимо было составить отчет и презентацию для защиты проекта.

Уточнение исходных и выходных данных
Итоговой программой должна была являться не программа для решения геометрической задачи и его иллюстрации, а игра, следовательно, исходные данные представляли из себя совокупность данных, получаемых от пользователя, а на выходе необходимо было получить соответствующие этим данным изменения в игровом процессе. 
Таким образом, необходимо было выполнить состыковку между данными, получаемыми от пользователя, и методами программы, которые должны были запускаться в зависимости от вида входных данных и вызывать соответствующие изменения в игровом процессе.
Входные данные, к примеру, могли из себя представлять:
•	Информацию о нажатии пользователем определенной кнопки на дисплее
•	Текст, введенный пользователем в конкретное поле игры
•	Информацию о длительном бездействии игрока
Объем входных данных ограничен в данном случае способностями программы (нельзя, к примеру, получить информацию об одновременном нажатии игроком двух кнопок)



Физическая модель для монстров и персонажа
Для работы с физикой в Unity используется RigidBody, то есть специальный компонент, добавляемый на объекты для создания эффектов физического движения.  
Поясню использование этого компонента для контроля физики на примере главного героя.
 
В скрипте главного героя Hero.cs создавалось приватное поле типа RigidBody2D и получалась ссылка на компонент RigidBody2D, помещенный на персонажа в Unity.  
В дальнейшем с помощью этого компонента можно было контролировать «массу» персонажа, его тип (статичный объект, динамический или кинематический), а значит, и контролировать высоту прыжка в скрипте, легкость отталкивания героя и т.п.
Для моделирования движения персонажа в прыжке была использована движком модель движения тела, брошенного под углом к горизонту, т.е. модель свободного падения тела.
Чтобы создать неподвижного монстра, был использована кинематический тип персонажа. При столкновении героя с неподвижным мобом, герой и моб получали урон.
Чтобы создать подвижного монстра, который бегает от одного места к другому, был также использован кинематический тип персонажа. При столкновении с невидимым препятствием, этот моб разворачивался и начинал движение в противоположном направлении. Процесс получения урона здесь такой же, как и у персонажа с неподвижным мобом.


Анализ используемой структуры данных
Входные данные, то есть данные, получаемые из движка Unity и касающиеся непосредственно настроек игры, получаются в скрипте в методе Awake() и хранятся в ячейках памяти.
 Типы данных выбирать не приходится в большинстве случаев. Но такие данные, как число жизней героя или монстра, так как являются целочисленными, имеют соответствующий тип при их определении в скрипте (int). Переменные же, отвечающие за скорость перемещения либо высоту прыжка, являются вещественными для создания более точной анимации процесса, поэтому и хранятся с помощью соответствующего типа данных (float).
Для проведения некоторых операций (например, проверки столкновения игрока с другими объектами) необходимо использовать массив для хранения данных (в данном случае – списка объектов, с которыми возможно столкновение), так как нам потребуется пересмотр всех элементов.  
Для хранения изображений сердечек для главного персонажа также используется массив, так как требуется перебор элементов при нанесении персонажу урона (спрайт живого сердца заменяется на спрайт deadHeart). Размеры массивов подбираются в соответствии с количеством элементов, которое заранее известно.

Выбор метода решения (описание алгоритма)
1.	Выбор среды программирования (Visual Studio)
2.	Создание нового проекта в Unity
3.	Добавление сцены первого уровня
a.	Настройки камеры и канваса 
b.	Создание заднего фона
c.	Установка блоков для перемещения героя (с сохранением объектов в Prefab)
d.	Создание главного героя 
i.	Выбор спрайта
ii.	Создание объекта в Unity
iii.	Написание скрипта с элементарными перемещениями героя (ходьба, прыжок)
iv.	Добавление анимации для спрайта
e.	Создание монстров (процесс аналогичен процессу создания героя)
f.	Размещение всех элементов на уровне в Unity
g.	Настройки слоев (enemy, Player и т.д.)
h.	Добавление персонажу возможности атаковать
i.	Написание скрипта для всех сущностей (обобщение)
j.	Корректировка дизайна сцены
k.	Проверка работы первого уровня
4.	Добавление главного меню
a.	Настройки камеры и канваса
b.	Добавление заднего фона
c.	Добавление заголовка и его анимации
d.	Добавление кнопок для перехода к игре и создание скрипта для них
5.	Добавление на сцену первого уровня кнопок перехода в меню
6.	Создание второй сцены по аналогии с первой
7.	Настройка перехода между уровнями
8.	Создание окна завершения игры и настройка процесса завершения игры
a.	Создание сцены
b.	Создание скрипта для перехода на нее при убийстве всех монстров
9.	Проверка работы программы
10.	Отладка
11.	Контрольная проверка
Комментированный листинг
Код программы по рекомендации преподавателя будет в установленные сроки выложен на платформе GitHub со всеми необходимыми комментариями.
Пример работы программы
Две колонки делать не имеет смысла из-за специфики входных данных.
Примером работы программы может служить серия изображений с движением персонажа по уровню, главным меню и т.д.

 
Главное меню.

 

Меню выбора уровня.
 
Первый уровень.

Анализ работы программы
Программа работает исправно. Переходы между двумя существующими уровнями выполняются без багов, как и переход между двумя любыми сценами. 
Движение персонажа происходит вместе с анимацией. Но имеется недостаток – анимация атаки становится заметной уже после того, как врагу был нанесен урок, из-за чего кажется, что монстр умирает преждевременно. Возможное решение: сделать дополнительную анимацию смерти мобов, в результате чего последняя атака персонажа будет происходить одновременно с анимацией смерти мобов, т.е. задержка перестанет существовать. 
Жизни персонажа исчезают по порядку и в правильный момент времени.
Монстры летают по заданной траектории. Но есть недостаток - персонаж способен отталкиваться от прозрачных объектов, созданных для направления движения монстров. Возможное решение: исправить код движения монстров, заставив их двигаться в определенном направление конечное число секунд, после чего следовал бы разворот. Это позволит избавиться от прозрачных блоков и, как следствие, от двойного прыжка героя.
Имеется возможность развивать программу и далее, добавляя новые уровни и улучшая качество анимации и дизайна.
